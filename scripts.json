{
    "create a node sequelize model": {
      "prefix": "model",
      "body": [
        "const { DataTypes } = require('sequelize');",
        "const { db } = require('../database/config');",
        "",
        "const ${1:ModelName} = db.define('${2:modelName}', {",
        "    field1: {",
        "        type: DataTypes.STRING,",
        "        allowNull: false",
        "    },",
        "});",
        "",
        "module.exports = ${1:ModelName};"
      ]
    },
    "create a node controller file": {
      "prefix": "controller",
      "body": [
        "const catchAsync = require('../utils/catchAsync');",
        "const ${1:modelName} = require('../models/${2:modelFile}');",
        "",
        "exports.findAll = catchAsync(async(req, res, next) => {",
        "    return res.json(/* valor a retornar */)",
        "});"
      ]
    },
    "create a node middleware file": {
      "prefix": "middleware",
      "body": [
        "const catchAsync = require('../utils/catchAsync');",
        "const ${1:modelName} = require('../models/${2:modelFile}');",
        "",
        "exports.${3:middlewareName} = catchAsync(async(req, res, next) => {",
        "  /* valor a retornar */",
        "  next();",
        "});"
      ]
    },
    "create a node router file": {
      "prefix": "router",
      "body": [
        "const ${1:controllerFile} = require('../controllers/${2:controllerFile}');",
        "const express = require('express');",
        "",
        "const router = express.Router();",
        "",
        "router.get('/', ${1:controllerFile}.findAll)",
        "",
        "module.exports = router"
      ]
    },
    "create a node generate JWT": {
      "prefix": "generatejwt",
      "body": [
        "const jwt = require('jsonwebtoken');",
        "",
        "const generateJWT = id => {",
        "  return new Promise((resolve, reject) => {",
        "    const payload = { id };",
        "",
        "    jwt.sign(",
        "      payload,",
        "      process.env.SECRET_JWT_SEED,",
        "      {",
        "        expiresIn: process.env.JWT_EXPIRE_IN,",
        "      },",
        "      (err, token) => {",
        "        if (err) {",
        "          console.log(err);",
        "          reject(err);",
        "        }",
        "",
        "        resolve(token);",
        "      }",
        "    );",
        "  });",
        "};",
        "",
        "module.exports = generateJWT"
      ]
    },
    "create a node catchAsync Function": {
      "prefix": "catchAsync",
      "body": [
        "const catchAsync = fn => {",
        "  return (req, res, next) => {",
        "    fn(req, res, next).catch(next);",
        "  };",
        "};",
        "",
        "module.exports = catchAsync;"
      ]
    },
    "create a node AppError class": {
      "prefix": "AppError",
      "body": [
        "class AppError extends Error {",
        "  constructor(message, statusCode) {",
        "    super(message);",
        "",
        "    this.statusCode = statusCode;",
        "    this.status = `${statusCode}`.startsWith('4') ? 'error' : 'fail';",
        "    this.isOperational = true;",
        "",
        "    Error.captureStackTrace(this, this.constructor);",
        "  }",
        "}",
        "",
        "module.exports = AppError;"
      ]
    },
    "create a node validateFields middleware": {
      "prefix": "validateFields",
      "body": [
        "const { validationResult } = require('express-validator');",
        "",
        "exports.validateFields = (req, res, next) => {",
        "  const errors = validationResult(req);",
        "",
        "  if (!errors.isEmpty()) {",
        "    return res.status(400).json({",
        "      status: 'error',",
        "      errors: errors.mapped(),",
        "    });",
        "  }",
        "",
        "  next();",
        "};"
      ]
    },
    "create a node restrictTo middleware": {
      "prefix": "restrictTo",
      "body": [
        "exports.restrictTo = (...roles) => {",
        "  return (req, res, next) => {",
        "    if (!roles.includes(req.sessionUser.role)) {",
        "      return next(",
        "        new AppError('You do not have permission to perfom this action.!', 403)",
        "      );",
        "    }",
        "",
        "    next();",
        "  };",
        "};"
      ]
    },
    "create a node protectAccountOwner middleware": {
      "prefix": "protectAccountOwner",
      "body": [
        "exports.protectAccountOwner = catchAsync(async (req, res, next) => {",
        "  const { user, sessionUser } = req;",
        "",
        "  if (user.id !== sessionUser.id) {",
        "    return next(new AppError('You do not own this account.', 401));",
        "  }",
        "",
        " next();",
        "});"
      ]
    },
    "create a node sequelize connection": {
      "prefix": "sequelizeConnection",
      "body": [
        "const { Sequelize } = require('sequelize');",
        "",
        "const db = new Sequelize({",
        "  dialect: '',",
        "  host: '',",
        "  username: '',",
        "  password: '',",
        "  database: '',",
        "  logging: false,",
        "});",
        "",
        "module.exports = { db };"
      ]
    },
    "create a node protect route": {
      "prefix": "protectRoute",
      "body": [
        "const { promisify } = require('util');",
        "const jwt = require('jsonwebtoken');",
        "",
        "const ${1:ModelName} = require('../models/${2:ModelFile}');",
        "",
        "exports.protect = catchAsync(async (req, res, next) => {",
        "  let token;",
        "  if (",
        "    req.headers.authorization &&",
        "    req.headers.authorization.startsWith('Bearer')",
        "  ) {",
        "    token = req.headers.authorization.split(' ')[1];",
        "  }",
        "",
        "  if (!token) {",
        "    return next(",
        "      new AppError('You are not logged in! Please log in to get access', 401)",
        "    );",
        "  }",
        "",
        "  const decoded = await promisify(jwt.verify)(",
        "    token,",
        "    process.env.SECRET_JWT_SEED",
        "  );",
        "",
        "  const user = await ${1:ModelName}.findOne({",
        "    where: {",
        "      id: decoded.id,",
        "      status: true,",
        "    },",
        "  });",
        "",
        "  if (!user) {",
        "    return next(",
        "      new AppError('The owner of this token it not longer available', 401)",
        "    );",
        "  }",
        "",
        "  //only if you have the functionality to change password",
        "  /*",
        "  if (user.passwordChangedAt) {",
        "    const changedTimeStamp = parseInt(",
        "      const changedTimeStamp = parseInt(",
        "      10",
        "    );",
        "",
        "    if (decoded.iat < changedTimeStamp) {",
        "      return next(",
        "        new AppError(",
        "          'User recently changed password!, please login again.',",
        "          401",
        "        )",
        "      );",
        "    }",
        "  }",
        "  */",
        "",
        "  req.sessionUser = user;",
        "  next();",
        "});"
      ]
    },
    "create a node error controller": {
      "prefix": "globalErrorHandler",
      "body": [
        "const AppError = require('../utils/appError');",
        "",
        "const sendErrorDev = (err, res) => {",
        "  res.status(err.statusCode).json({",
        "    status: err.status,",
        "    error: err,",
        "    message: err.message,",
        "    stack: err.stack,",
        "  });",
        "};",
        "",
        "const sendErrorProd = (err, res) => {",
        "  if (err.isOperational) {",
        "    res.status(err.statusCode).json({",
        "      status: err.status,",
        "      message: err.message,",
        "    });",
        "  } else {",
        "    console.error('ERROR ðŸ§¨', err);",
        "    res.status(500).json({",
        "      status: 'fail',",
        "      message: 'Something went very wrong!',",
        "    });",
        "  }",
        "};",
        "",
        "const globalErrorHandler = (err, req, res, next) => {",
        "  err.statusCode = err.statusCode || 500;",
        "  err.status = err.status || 'fail';",
        "",
        "  if (process.env.NODE_ENV === 'development') {",
        "    sendErrorDev(err, res);",
        "  }",
        "",
        "  if (process.env.NODE_ENV === 'production') {",
        "    let error = { ...err };",
        "",
        "    if (!error.parent?.code) {",
        "      error = err;",
        "    }",
        "",
        "    /* valid errors */",
        "",
        "    sendErrorProd(error, res);",
        "  }",
        "};",
        "",
        "module.exports = globalErrorHandler;"
      ]
    }
  }
  